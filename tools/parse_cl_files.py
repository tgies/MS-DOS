#!/usr/bin/env python3
"""
DOS Message Class File Parser
=============================
Parses .CL* (message class) assembly files to extract message structure.

These files are generated by BUILDMSG and contain:
- Class headers with ID, version, message count
- Message ID tables with IDs and offsets
- Length-prefixed message strings

Usage:
    parse_cl_files.py format.clb
"""

import sys
import re
from pathlib import Path
from typing import List, Dict, Tuple
from dataclasses import dataclass

@dataclass
class Message:
    """A single message from a class file"""
    msg_id: int
    text: str
    length: int

    def __repr__(self):
        text_preview = self.text[:50] + '...' if len(self.text) > 50 else self.text
        return f"<Message {self.msg_id:04X}: len={self.length}, '{text_preview}'>"


@dataclass
class MessageClass:
    """A message class containing multiple messages"""
    class_id: int
    class_name: str
    messages: Dict[int, Message]

    def __repr__(self):
        return f"<MessageClass {self.class_name} (0x{self.class_id:02X}): {len(self.messages)} messages>"


class CLFileParser:
    """Parse DOS message class (.CL*) assembly files"""

    def __init__(self, cl_path: Path):
        self.cl_path = cl_path
        self.content = cl_path.read_text(encoding='latin1', errors='replace')
        self.lines = self.content.splitlines()

    def parse(self) -> MessageClass:
        """Parse the .CL* file and extract message class"""
        # Extract class ID from $M_CLASS_ID macro
        class_id = self._extract_class_id()
        class_name = self._extract_class_name()

        # Extract all messages
        messages = self._extract_messages()

        return MessageClass(
            class_id=class_id,
            class_name=class_name,
            messages=messages
        )

    def _extract_class_id(self) -> int:
        """Extract class ID from $M_CLASS_ID <0FFH,...>"""
        for line in self.lines:
            # Match: $M_CLASS_ID <0FFH,EXPECTED_VERSION,Class_B_MessageCount>
            match = re.search(r'\$M_CLASS_ID\s+<([0-9A-Fa-f]+)H?', line)
            if match:
                return int(match.group(1), 16)

        raise ValueError(f"Could not find class ID in {self.cl_path}")

    def _extract_class_name(self) -> str:
        """Extract class name from PUBLIC $M_CLS_X or filename"""
        for line in self.lines:
            # Match: PUBLIC  $M_CLS_2 or $M_MSGSERV_1
            match = re.search(r'PUBLIC\s+\$M_(?:CLS|MSGSERV)_(\w+)', line)
            if match:
                return match.group(1)

        # Fallback: use filename
        return self.cl_path.stem

    def _extract_messages(self) -> Dict[int, Message]:
        """Extract all messages from the file"""
        messages = {}

        # Find message definitions: $M_X_YYYYYH_MSG LABEL BYTE
        i = 0
        while i < len(self.lines):
            line = self.lines[i]

            # Match message label: $M_B_00015H_MSG LABEL BYTE
            msg_match = re.match(r'\$M_\w+_([0-9A-Fa-f]+)H?_MSG\s+LABEL\s+BYTE', line)
            if msg_match:
                msg_id = int(msg_match.group(1), 16)

                # Next line should be: DB $M_B_00015H_END-$M_B_00015H_MSG-1
                # Following lines are: DB CR,"message text",CR,LF or DB "text"
                # Until we hit: $M_B_00015H_END LABEL BYTE

                i += 1  # Skip length definition line

                # Extract message text lines
                text_parts = []
                while i < len(self.lines):
                    i += 1
                    text_line = self.lines[i].strip()

                    # End of message?
                    if '_END' in text_line and 'LABEL BYTE' in text_line:
                        break

                    # Extract text from DB directives
                    text = self._extract_text_from_db(text_line)
                    if text is not None:
                        text_parts.append(text)

                full_text = ''.join(text_parts)
                messages[msg_id] = Message(
                    msg_id=msg_id,
                    text=full_text,
                    length=len(full_text)
                )

            i += 1

        return messages

    def _extract_text_from_db(self, line: str) -> str:
        """Extract text from DB directive line"""
        if not line.startswith('DB'):
            return None

        # Remove 'DB' and leading whitespace
        line = line[2:].strip()

        result = []
        parts = line.split(',')

        for part in parts:
            part = part.strip()

            # String literal: "text"
            if part.startswith('"') and part.endswith('"'):
                result.append(part[1:-1])

            # CR (carriage return)
            elif part == 'CR':
                result.append('\r')

            # LF (line feed)
            elif part == 'LF':
                result.append('\n')

            # Hex value: 0Dh, 0AH, etc.
            elif part.endswith('H') or part.endswith('h'):
                try:
                    value = int(part[:-1], 16)
                    if value == 0x0D:
                        result.append('\r')
                    elif value == 0x0A:
                        result.append('\n')
                    else:
                        result.append(chr(value))
                except (ValueError, IndexError):
                    pass

        return ''.join(result)


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <CL_FILE>", file=sys.stderr)
        print(f"", file=sys.stderr)
        print(f"Example: {sys.argv[0]} format.clb", file=sys.stderr)
        sys.exit(1)

    cl_path = Path(sys.argv[1])

    if not cl_path.exists():
        print(f"Error: {cl_path} not found", file=sys.stderr)
        sys.exit(1)

    parser = CLFileParser(cl_path)
    msg_class = parser.parse()

    print(f"Parsed {msg_class}")
    print(f"{'=' * 70}")
    print()

    for msg_id, message in sorted(msg_class.messages.items()):
        # Format message for display
        text_display = message.text.replace('\r', '<CR>').replace('\n', '<LF>')
        print(f"[{msg_id:04X}] {text_display}")


if __name__ == "__main__":
    main()
